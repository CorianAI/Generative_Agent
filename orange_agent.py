import sqlite3

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import os
import pickle
import openai
from apikey import APIKEY

openai.api_key = APIKEY

class ChatBot:
    def __init__(self, system=""):
        self.system = system
        self.messages = []

    def __call__(self, message):
        output = openai.text_completion.create(
        model="gpt-3.5-turbo", 
        messages=[{"role": "user", "content": message}]
        )

        return output.choices[0].message.content

class MemoryStore:
    def __init__(self, file_path="memory.pkl"):
        self.file_path = file_path
        if os.path.exists(file_path):
            self.load_db()
        else:
            self.memory = []
            self.vectorizer = TfidfVectorizer()
            self.tfidf_matrix = None

    def add_memory(self, memory):
        self.memory.append(memory)
        self.tfidf_matrix = self.vectorizer.fit_transform(self.memory)
        self.save_db()
        
    def get_relevant_memory(self, input_str):
        input_vector = self.vectorizer.transform([input_str])
        cosine_similarities = cosine_similarity(input_vector, self.tfidf_matrix).flatten()
        most_similar_index = cosine_similarities.argmax()
        return self.memory[most_similar_index]
    
    def get_relevant_memories(self, input_str, top_n=3):
        input_vector = self.vectorizer.transform([input_str])
        cosine_similarities = cosine_similarity(input_vector, self.tfidf_matrix).flatten()
        most_similar_indices = cosine_similarities.argsort()[-top_n:][::-1]
        return [self.memory[i] for i in most_similar_indices]
    
    def save_db(self):
        with open(self.file_path, 'wb') as f:
            pickle.dump((self.memory, self.vectorizer, self.tfidf_matrix), f)

    def load_db(self):
        with open(self.file_path, 'rb') as f:
            self.memory, self.vectorizer, self.tfidf_matrix = pickle.load(f)

class GenerativeAgent:
    def __init__(self, name, age, traits):
        self.name = name
        self.age = age
        self.traits = traits
        self.status = 'active'
        self.memory_store = MemoryStore()

    def generate(self, prompt):
        output = openai.ChatCompletion.create(
        model="gpt-3.5-turbo", 
        messages=[{"role": "user", "content": prompt}]
        )

        return output.choices[0].message.content


    def add_memory(self, memory):
        # To Do: Rank the memory being stored based on how mundane it appears to be 
        # (Might need more context, but would be interesting if capable based solely on the data going in.)
        self.memory_store.add_memory(memory)

    def learn_from_interaction(self, input_str, response):
        self.add_memory(input_str)
        self.add_memory(response)

    def should_reply(self, input_str):
        # Rank the likelihood of 
        return True # '?' in input_str
    
    def generate_dialogue(self, input_str):
        if not self.should_reply(input_str):
            self.add_memory(input_str)
            return None  # No response is needed
        
        # Placeholder for improved memory retrieval using NLP
        relevant_memory = self.memory_store.get_relevant_memory(input_str)

        # Placeholder for advanced dialogue model.
        relevant_memories = self.memory_store.get_relevant_memories(input_str)
        memories = f'{input_str} asked {self.name}, who is {self.traits} and {self.age}, and recalls the following memories:\n'
        memories += '\n'.join([f'"{mem}"' for mem in relevant_memories])

        #placeholder for actual replier
        preresponse = f'Me: "{relevant_memory}"'
        response = f'{self.name} said, "{relevant_memory}"'
        if 'curious' in self.traits:
            response += ' Can you tell me more?'
        if 'observant' in self.traits and 'remember' in relevant_memory:
            response += ' I noticed that this is related to something I remember.'

        # Generate Replies for real.
       # response = self.generate(memories) # This would be generated by an advanced dialogue model
        #feed it all back in and add it to learned data.
        self.learn_from_interaction(input_str, preresponse)
        return response

    def get_summary(self):
        return {
            'Name': self.name,
            'Age': self.age,
            'Traits': self.traits,
            'Status': self.status,
            'Memories': self.memory_store.memory
        }

    def age_agent(self, years):
        self.age += years
        if self.age > 100:
            self.status = 'inactive'
            print(f'{self.name} has become inactive due to age.')
        else:
            print(f'{self.name} is now {self.age} years old.')

# Create an instance of the GenerativeAgent class
agent = GenerativeAgent('Agent1', 30, ['curious', 'observant'])
# Add some memories to the agent
agent.add_memory('I remember learning about generative agents.')
agent.add_memory('Generative agents can generate responses based on their memories.')
agent.add_memory('Generative agents can be used in simulations.')
# Generate a dialogue response from the agent
response = agent.generate_dialogue('Tell me about generative agents.')
print(response)
# Generate another dialogue response from the agent
response = agent.generate_dialogue('What can generative agents do?')
print(response)
# Age the agent by 5 years
agent.age_agent(5)
# Get a summary of the agent
summary = agent.get_summary()
print(summary)
while True:
    user_input = input()
    response = agent.generate_dialogue(user_input)
    print(response)